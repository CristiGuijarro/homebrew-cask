#!/usr/bin/env ruby 

require 'optparse'
require 'date'
require 'yaml'
require 'erb'

class Template
  include ERB::Util
  attr_accessor :class, :name, :version, :deps
  
  def initialize(name, config, date=Time.now)
    @class = name.split('-').map(&:capitalize).join('')
    @name = name
    @version = config['version']
    @deps = config['deps']
    @date = date
  end
  
  def render
    ERB.new(get_template()).result(binding)
  end
  
  def check?(original)
    new_content = render
    original_minus_date = original.split("\n")[1..-1].join("\n")
    new_content_minus_date = new_content.split("\n")[1..-1].join("\n")
    return original_minus_date == new_content_minus_date
  end

  def save(file)
    File.open(file, "w+") do |f|
      f.write(render)
    end
  end

  def get_template
    %{#Template generated on <%= @date %>
#Do not edit this file. Modify the relevant config and regenerate
require 'digest'
class <%= @class %> < Formula
  url 'file://'+File.expand_path(__FILE__)
  desc 'Dependencies for the <%= @class%> formula'
  sha256 Digest::SHA256.file(File.expand_path(__FILE__)).hexdigest
  version '<%= version %>'
<% for @dep in @deps %>
  depends_on '<%= @dep %>'
<% end %>
  def install
    File.open('<%= @name %>', 'w') { |file|
      file.write '#!/bin/sh'+"\\n"
      deps.each do | dep |
        f = dep.to_formula
        file.write "echo "+[f.full_name, f.version, f.prefix].join("\\t")+"\\n"
      end
    }
    bin.install '<%= @name %>'
  end
end
    }
  end
end

class App
  VERSION = '1.1.0'
  
  attr_reader :options
  attr_writer :opt_parser
  attr_writer :config

  def initialize(arguments, stdin)
    @arguments = arguments
    @stdin = stdin
    
    # Set defaults
    @options = {}
    @options[:verbose] = false
    @options[:quiet] = false
  end

  # Parse options, check arguments, then process the command
  def run
    if ! parse_options?
      puts @opt_parser
      exit 1
    end
    if @options[:verbose]
      puts "Start at #{DateTime.now}\n"
      output_options
    end
    arguments_valid?
    process_command
    puts "Finished at #{DateTime.now}\n" if @options[:verbose]
  end
  
  def parse_options?
    @opt_parser = OptionParser.new do |opt|
      opt.banner = 'Generate casks of Ensembl dependencies for (linux/home)brew'
      opt.separator  ""
      opt.separator  "Usage"
      opt.separator  "     create_cask -c config.yml -d path/to/dir"
      opt.separator  ""
      opt.separator  "Options"
      
      opt.on('-v', '--version', 'Display the version, then exit') do
        output_version
        exit 0
      end
      
      opt.on_tail('-h', '--help', 'Displays help message') do
        puts opt
        exit 0
      end
      
      opt.on('-V', '--verbose', 'Verbose output') do
        @options[:verbose] = true
      end
      
      opt.on('-q', '--quiet', 'Output as little as possible, overrides verbose') do
        @options[:quiet] = true
      end
    
      opt.on('-c', '--config config', 'YAML config. Can also specify a glob e.g. yml/* or a directory') do  |c|
        @options[:configs] = []
        if File.directory? c
          @options[:configs] = Dir.glob("#{c}/*.yml")
        elsif File.file? c
          @options[:configs] << c
        elsif
          @options[:configs] = Dir.glob(c) # assume it was a glob pattern
        end
        
        if @options[:configs].empty?
          raise OptionParser::InvalidArgument.new("No yml config files found at given path #{c}")
        end
        
        @configs = @options[:configs].map { | config | puts config; YAML.load_file(config) }
      end
      
      opt.on('-d', '--dir dir', 'Output directory') do |d|
        raise OptionParser::InvalidArgument.new("No directory found at given path #{d}") if ! File.directory?(d)
        @options[:dir] = d 
      end
      
    end
    
    begin
      @opt_parser.parse!(@arguments)
    rescue OptionParser::ParseError
      $stderr.puts "Error: #{$!}"
      exit 1
    end
    return true
  end

  # Performs post-parse processing on options
  def process_options
    @options[:verbose] = false if @options[:quiet]
  end
  
  def output_options
    puts "Options:\n"
    @options.each do |name, val|        
      puts "  #{name} = #{val}"
    end
  end

  def arguments_valid?
    if ! @options[:configs]
      $stderr.puts "No --config given"
      exit 1
    end
    if ! @options[:dir]
      $stderr.puts "No --dir given"
      exit 1
    end
  end

  def output_version
    puts "#{File.basename(__FILE__)} version #{VERSION}"
  end

  def process_command
    @configs.each do |config|
      config.each do |k,v|
        target = File.join(@options[:dir], "#{k}.rb")
        
        template = Template.new(k,v)

        # If the target exists then check
        write_content = true
        if File.exists? target
          original_content = File.read target
          if template.check? original_content
            write_content = false
          end
        end
        
        if write_content
          puts "Processing #{k} and outputting to #{target}\n" if @options[:verbose]
          template.save(target)
        else
          puts "Skipping #{k} as content was the same as found in #{target}\n" if @options[:verbose]
        end
      end
    end
  end
end

# Create and run the application
app = App.new(ARGV, STDIN)
app.run
